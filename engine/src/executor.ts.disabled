import { PRMetadata, ValidationResult, GameState, BoardElement } from './types.js';
import { loadState, saveState } from './loader.js';
import { getFileContent } from './parser.js';

const CGA_COLORS = [
  '#000000', '#0000AA', '#00AA00', '#00AAAA',
  '#AA0000', '#AA00AA', '#AA5500', '#AAAAAA',
  '#555555', '#5555FF', '#55FF55', '#55FFFF',
  '#FF5555', '#FF55FF', '#FFFF55', '#FFFFFF'
];

/**
 * Generate random CGA color (excluding black)
 */
function randomCGAColor(): string {
  const colors = CGA_COLORS.slice(1); // Skip black
  return colors[Math.floor(Math.random() * colors.length)];
}

/**
 * Generate random position on board with some padding
 */
function randomPosition(width: number, height: number): { x: number; y: number } {
  const padding = 50;
  return {
    x: padding + Math.floor(Math.random() * (width - padding * 2)),
    y: padding + Math.floor(Math.random() * (height - padding * 2))
  };
}

/**
 * Generate unique element ID
 */
function generateElementId(state: GameState): string {
  const count = state.board.elements.length;
  return `elem_${String(count + 1).padStart(3, '0')}`;
}

/**
 * Hash author name
 */
function hashAuthor(author: string): string {
  let hash = 0;
  for (let i = 0; i < author.length; i++) {
    hash = ((hash << 5) - hash) + author.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash).toString(16);
}

/**
 * Apply effect from a validated PR
 */
export function applyEffect(pr: PRMetadata, result: ValidationResult): void {
  const state = loadState();
  
  if (!result.effects || result.effects.length === 0) {
    console.log('No effects to apply');
    return;
  }
  
  const effect = result.effects[0];
  const ruleId = effect.rule_id;
  
  if (effect.effect.action === 'add_to_board') {
    const file = pr.files_added[0];
    const content = getFileContent(file);
    
    // Create element
    const pos = randomPosition(state.board.width, state.board.height);
    const color = randomCGAColor();
    
    const element: BoardElement = {
      id: generateElementId(state),
      type: effect.effect.element.type,
      content: content.toUpperCase(), // Arcade style: ALL CAPS
      x: pos.x,
      y: pos.y,
      color: color,
      size: effect.effect.element.size,
      added_by_pr: `#${pr.number}`,
      added_at: pr.timestamp,
      rule_id: ruleId
    };
    
    state.board.elements.push(element);
  }
  
  // Update score
  state.score.total += result.points;
  state.score.today += result.points;
  
  // Update player stats
  const playerHash = hashAuthor(pr.author);
  if (!state.players[playerHash]) {
    state.players[playerHash] = {
      prs_merged: 0,
      points_contributed: 0,
      first_seen: pr.timestamp
    };
    state.meta.total_players += 1;
  }
  
  state.players[playerHash].prs_merged += 1;
  state.players[playerHash].points_contributed += result.points;
  
  // Update rule stats
  if (!state.rules_triggered[ruleId]) {
    state.rules_triggered[ruleId] = 0;
  }
  state.rules_triggered[ruleId] += 1;
  
  // Update meta
  state.meta.total_prs += 1;
  state.last_pr = `#${pr.number}`;
  state.last_updated = new Date().toISOString();
  
  saveState(state);
  
  console.log(`âœ… Effect applied! +${result.points} points`);
  if (newElement) {
    console.log(`   Element "${newElement.content}" added at (${newElement.x}, ${newElement.y})`);
  }
  console.log(`   Total score: ${state.score.total}`);
}
