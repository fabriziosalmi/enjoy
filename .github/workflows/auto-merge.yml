name: Auto Merge

on:
  pull_request:
    types: [labeled]

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CONCURRENCY CONTROL - Serialize merges to prevent state.json conflicts
# Only one merge at a time, others wait in queue
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
concurrency:
  group: enjoy-game-state
  cancel-in-progress: false  # Queue merges, don't cancel

jobs:
  merge:
    if: contains(github.event.pull_request.labels.*.name, 'auto-merge')
    # ‚ö†Ô∏è SECURITY: NEVER use self-hosted runner here!
    # This workflow processes untrusted PR content from forks.
    # A malicious PR could execute arbitrary code on your runner.
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      
    steps:
      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      # SECURITY: Double-check files before merge (defense in depth)
      # Never trust labels alone - always verify!
      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      - name: Security Pre-Check
        id: security
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const ALLOWED_PATTERNS = [
              /^words\/[A-Za-z0-9_-]+\.txt$/,
            ];
            
            const MAINTAINERS = ['fabriziosalmi'];
            const prAuthor = context.payload.pull_request.user.login;
            const isMaintainer = MAINTAINERS.includes(prAuthor);
            
            const KNOWN_BOTS = ['github-actions[bot]', 'dependabot[bot]', 'dependabot', 'renovate[bot]', 'codecov[bot]', 'copilot[bot]'];
            const isBot = KNOWN_BOTS.includes(prAuthor) || prAuthor.includes('[bot]') || prAuthor.endsWith('-bot');
            
            if (isMaintainer || isBot) {
              console.log('‚úÖ Maintainer/Bot bypass - merge allowed');
              core.setOutput('allowed', 'true');
              return;
            }
            
            const changedFiles = files
              .filter(f => f.status !== 'removed')
              .map(f => f.filename);
            
            // Security validation function (mirrors validate-pr.yml)
            const isSecurityViolation = (file) => {
              if (file.includes('..') || file.includes('//')) return 'path_traversal';
              if (file.startsWith('.') || file.includes('/.')) return 'hidden_file';
              if (file.startsWith('.github/') || file === '.github') return 'github_folder';
              if (/[\u200B-\u200D\uFEFF\u00A0]/.test(file)) return 'unicode_trick';
              const lower = file.toLowerCase();
              if (lower.includes('.git/') || lower === '.git') return 'git_folder';
              if (lower.includes('node_modules/')) return 'node_modules';
              if (/\.(sh|bash|py|rb|pl|exe|bat|cmd|ps1|js|mjs|cjs|ts|php|jar|class)$/i.test(file)) return 'executable';
              if (/^(\.env|\.npmrc|\.yarnrc|package\.json|package-lock\.json|yarn\.lock|Makefile|Dockerfile|docker-compose\.ya?ml)$/i.test(file)) return 'config_file';
              return null;
            };
            
            const violations = [];
            const unauthorized = [];
            
            for (const file of changedFiles) {
              const violation = isSecurityViolation(file);
              if (violation) {
                violations.push(`${file} (${violation})`);
              } else if (!ALLOWED_PATTERNS.some(p => p.test(file))) {
                unauthorized.push(file);
              }
            }
            
            if (violations.length > 0) {
              console.log('üî¥ SECURITY VIOLATIONS:', violations);
              core.setOutput('allowed', 'false');
              core.setOutput('blocked', violations.join(', '));
              core.setOutput('reason', 'security_violation');
              return;
            }
            
            if (unauthorized.length > 0) {
              console.log('üö´ BLOCKED - Unauthorized files:', unauthorized);
              core.setOutput('allowed', 'false');
              core.setOutput('blocked', unauthorized.join(', '));
              core.setOutput('reason', 'not_in_allowlist');
              return;
            }
            
            console.log('‚úÖ All files allowed:', changedFiles);
            core.setOutput('allowed', 'true');
      
      - name: Block Unauthorized Merge
        if: steps.security.outputs.allowed != 'true'
        run: |
          echo "üö´ MERGE BLOCKED - Security check failed!"
          echo "Unauthorized files: ${{ steps.security.outputs.blocked }}"
          echo ""
          echo "This PR was labeled 'auto-merge' but contains unauthorized files."
          echo "The label should be removed and the PR reviewed manually."
          exit 1
      
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: engine/package-lock.json

      - name: Configure git
        run: |
          git config user.name "enjoy-bot"
          git config user.email "bot@enjoy.game"
      
      - name: Fetch and merge PR
        run: |
          git fetch origin pull/${{ github.event.pull_request.number }}/head:pr-branch
          git merge pr-branch --no-ff -m "üéÆ Merge PR #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}"
      
      - name: Install engine dependencies
        run: |
          cd engine
          npm ci
      
      - name: Build engine
        run: |
          cd engine
          npm run build
      
      - name: Apply karma and update state
        id: apply
        env:
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          cd engine
          node -e "
            const fs = require('fs');
            const { loadState, saveState } = require('./dist/loader.js');
            const { applyKarma, trackReferral, applyReferralKarma, checkAchievements, analyzeContributionQuality } = require('./dist/karma.js');
            const { extractReferral } = require('./dist/validator.js');
            const { generateLeaderboardMarkdown } = require('./dist/leaderboard.js');
            const { applyDecaySystem, getDecayStatus } = require('./dist/decay.js');
            
            const state = loadState();
            
            // Check decay first
            const decayResult = applyDecaySystem(state);
            if (decayResult.karma_decay.decayed || decayResult.level_decay.decayed) {
              console.log('Decay applied:', decayResult.message);
            }
            
            // Get PR info
            const author = process.env.PR_AUTHOR || 'unknown';
            const prBody = process.env.PR_BODY || '';
            
            // Find added .txt files
            const txtFiles = fs.readdirSync('.').filter(f => f.endsWith('.txt') && !f.startsWith('.'));
            let content = '';
            if (txtFiles.length > 0) {
              content = fs.readFileSync(txtFiles[0], 'utf8').trim();
            }
            
            // Create PR object
            const pr = {
              number: ${{ github.event.pull_request.number }},
              author: author,
              commit_message: '${{ github.event.pull_request.title }}',
              files_added: txtFiles,
              timestamp: new Date().toISOString()
            };
            
            // Analyze and apply karma
            const karma = analyzeContributionQuality(pr, content, state);
            applyKarma(state, pr, karma);
            
            // Track referral
            const referral = extractReferral(prBody);
            if (referral) {
              trackReferral(state, referral, author);
              const achievements = applyReferralKarma(state, author, karma.quality_score, karma.amplification_factor);
              if (achievements.length > 0) {
                console.log('New achievements for referrer:', achievements);
              }
            }
            
            // Update state
            state.meta.total_prs++;
            if (!state.players[author]) {
              state.meta.total_players++;
            }
            state.last_updated = new Date().toISOString();
            state.last_pr = '#${{ github.event.pull_request.number }}';
            
            // Update score
            state.score.total += karma.quality_score;
            state.score.today += karma.quality_score;
            
            // Check level progress
            if (state.levels.next_unlock) {
              state.levels.next_unlock.progress.score = state.score.total;
              state.levels.next_unlock.progress.prs = state.meta.total_prs;
              
              // Check unlock
              const next = state.levels.next_unlock;
              if (next.progress.score >= next.requires_score && next.progress.prs >= next.requires_prs) {
                console.log('LEVEL UP! Unlocking level', next.level_id);
                state.levels.current = next.level_id;
                state.levels.unlocked.push(next.level_id);
                
                // Set next level
                if (next.level_id < 100) {
                  state.levels.next_unlock = {
                    level_id: next.level_id + 1,
                    requires_score: Math.floor(next.requires_score * 1.5),
                    requires_prs: next.requires_prs + 5,
                    progress: { score: state.score.total, prs: state.meta.total_prs }
                  };
                } else {
                  state.levels.next_unlock = null;
                  console.log('MAX LEVEL 100 REACHED!');
                }
                
                fs.writeFileSync('level-unlocked.txt', 'true');
              }
            }
            
            // Save state
            saveState(state);
            
            // Output karma info
            console.log('Karma applied:', karma.quality_score, 'Amplification:', karma.amplification_factor);
            fs.writeFileSync('karma-applied.json', JSON.stringify({
              score: karma.quality_score,
              amplification: karma.amplification_factor,
              action: karma.action
            }));
          "
      
      - name: Update README leaderboard
        run: |
          cd engine
          node -e "
            const { loadState } = require('./dist/loader.js');
            const { generateLeaderboardMarkdown } = require('./dist/leaderboard.js');
            const fs = require('fs');
            
            const state = loadState();
            const leaderboard = generateLeaderboardMarkdown(state);
            
            let readme = fs.readFileSync('../README.md', 'utf8');
            
            // Update leaderboard section
            const startMarker = '## üèÜ Leaderboards';
            const endMarker = '\\n---\\n';
            
            if (readme.includes(startMarker)) {
              const start = readme.indexOf(startMarker);
              const afterStart = readme.substring(start);
              const endMatch = afterStart.match(/\\n---\\n/);
              if (endMatch) {
                const end = start + endMatch.index + endMatch[0].length;
                readme = readme.substring(0, start) + leaderboard + '\\n---\\n' + readme.substring(end);
              }
            }
            
            fs.writeFileSync('../README.md', readme);
            console.log('README updated with leaderboard');
          " || echo "Leaderboard update skipped"
      
      - name: Commit changes
        run: |
          git add state.json README.md
          git commit -m "üìä Update state from PR #${{ github.event.pull_request.number }} [skip ci]" || echo "No changes"
      
      - name: Push changes
        run: |
          git push origin main
      
      - name: Close PR with comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let levelUnlocked = false;
            let karmaInfo = { score: 0, amplification: 1 };
            let state = {};
            
            try {
              levelUnlocked = fs.existsSync('level-unlocked.txt');
              karmaInfo = JSON.parse(fs.readFileSync('engine/karma-applied.json', 'utf8'));
              state = JSON.parse(fs.readFileSync('state.json', 'utf8'));
            } catch(e) {}
            
            const author = context.payload.pull_request.user.login;
            const player = state.players?.[author] || { karma: 0, prs: 0 };
            const currentLevel = state.levels?.current || 1;
            const nextUnlock = state.levels?.next_unlock;
            const totalPlayers = state.meta?.total_players || 1;
            const rank = Object.entries(state.players || {})
              .sort((a, b) => b[1].karma - a[1].karma)
              .findIndex(([name]) => name === author) + 1;
            
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              state: 'closed'
            });
            
            let comment = `## üéâ Contribution Merged!\n\n`;
            
            comment += `### üíé Karma Earned\n`;
            comment += `| This PR | Your Total |\n`;
            comment += `|---------|------------|\n`;
            comment += `| **+${karmaInfo.score}** `;
            if (karmaInfo.amplification > 1) {
              comment += `(√ó${karmaInfo.amplification} üåü)`;
            }
            comment += ` | **${player.karma}** karma |\n\n`;
            
            comment += `### üìä Your Stats\n`;
            comment += `| Stat | Value |\n`;
            comment += `|------|-------|\n`;
            comment += `| üèÜ Rank | #${rank} of ${totalPlayers} players |\n`;
            comment += `| üìù Total PRs | ${player.prs} |\n`;
            comment += `| üî• Streak | ${player.streak || 0} days |\n\n`;
            
            if (levelUnlocked) {
              comment += `## üöÄ LEVEL UP! Level ${currentLevel} unlocked!\n\n`;
            }
            
            if (nextUnlock) {
              const karmaProgress = Math.min(100, Math.round((nextUnlock.progress.score / nextUnlock.requires_score) * 100));
              const prsProgress = Math.min(100, Math.round((nextUnlock.progress.prs / nextUnlock.requires_prs) * 100));
              const bar = (pct) => '‚ñà'.repeat(Math.round(pct/5)) + '‚ñë'.repeat(20 - Math.round(pct/5));
              
              comment += `### ‚è´ Progress to Level ${nextUnlock.level_id}\n`;
              comment += `\`\`\`\n`;
              comment += `Karma: [${bar(karmaProgress)}] ${nextUnlock.progress.score}/${nextUnlock.requires_score}\n`;
              comment += `PRs:   [${bar(prsProgress)}] ${nextUnlock.progress.prs}/${nextUnlock.requires_prs}\n`;
              comment += `\`\`\`\n\n`;
            }
            
            if (totalPlayers <= 50) {
              comment += `üèÖ **FOUNDER #${rank}** - This badge is permanent!\n\n`;
            }
            
            comment += `### üéØ Next Steps\n`;
            comment += `- ‚≠ê [Star the repo](https://github.com/${context.repo.owner}/${context.repo.repo})\n`;
            comment += `- üë• Invite friends: add \`Referred by @${author}\` in their PR\n`;
            comment += `- üîÑ Contribute again for streak bonus!\n\n`;
            comment += `---\n*Thank you for playing!* ‚ú®`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
