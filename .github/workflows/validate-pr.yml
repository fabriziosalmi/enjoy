name: Validate PR

on:
  pull_request:
    types: [opened, synchronize, reopened]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONCURRENCY CONTROL - Serialize PR processing to prevent state.json conflicts
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
concurrency:
  group: enjoy-game-state
  cancel-in-progress: false  # Don't cancel, queue instead

jobs:
  validate:
    # âš ï¸ SECURITY: NEVER use self-hosted runner here!
    # This workflow processes untrusted PR content from forks.
    # A malicious PR could execute arbitrary code on your runner.
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      
    steps:
      - name: Checkout repository (main branch for engine)
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Fetch PR word files only
        run: |
          # Fetch PR branch
          git fetch origin pull/${{ github.event.pull_request.number }}/head:pr-branch

          # Only checkout the words/ directory from PR (this is what players contribute)
          # Do NOT checkout other files - they might override engine fixes on main
          echo "ğŸ“ Checking out words/ from PR..."
          git checkout pr-branch -- words/ 2>/dev/null || mkdir -p words/

          # Show what files we have
          echo "ğŸ“‚ words/ directory:"
          ls -la words/ || echo "No word files"
      
      - name: Get changed files
        id: files
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SECURITY: ALLOWLIST APPROACH
            // Only specific file patterns are allowed for player contributions
            // Everything else is BLOCKED (not just ignored!)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const ALLOWED_PATTERNS = [
              // Player contributions (Level 1+)
              /^words\/[A-Za-z0-9_-]+\.txt$/,      // words/MYWORD.txt
              
              // Future levels - uncomment as game progresses
              // /^emoji\/[A-Za-z0-9_-]+\.txt$/,   // Level 5+
              // /^ascii\/[A-Za-z0-9_-]+\.txt$/,   // Level 10+
              // /^data\/[A-Za-z0-9_-]+\.json$/,   // Level 20+
              // /^svg\/[A-Za-z0-9_-]+\.svg$/,     // Level 30+
            ];
            
            // Maintainers can modify anything
            const MAINTAINERS = ['fabriziosalmi'];
            const prAuthor = context.payload.pull_request.user.login;
            const isMaintainer = MAINTAINERS.includes(prAuthor);
            
            // Bot detection
            const KNOWN_BOTS = [
              'github-actions[bot]', 'dependabot[bot]', 'dependabot',
              'renovate[bot]', 'codecov[bot]', 'copilot[bot]'
            ];
            const isBot = KNOWN_BOTS.includes(prAuthor) || 
                          prAuthor.includes('[bot]') || 
                          prAuthor.endsWith('-bot');
            
            const allAdded = files.filter(f => f.status === 'added').map(f => f.filename);
            const allModified = files.filter(f => f.status === 'modified').map(f => f.filename);
            const removed = files.filter(f => f.status === 'removed').map(f => f.filename);
            
            // Security check: normalize paths and check for tricks
            const normalizeAndValidate = (filename) => {
              // Block path traversal
              if (filename.includes('..') || filename.includes('//')) return { valid: false, reason: 'path_traversal' };
              // Block hidden files (starting with . or containing /.)
              if (filename.startsWith('.') || filename.includes('/.')) return { valid: false, reason: 'hidden_file' };
              // Block entire .github folder (not just workflows)
              if (filename.startsWith('.github/') || filename === '.github') return { valid: false, reason: 'github_folder' };
              // Block Unicode tricks (zero-width chars, homoglyphs)
              if (/[\u200B-\u200D\uFEFF\u00A0]/.test(filename)) return { valid: false, reason: 'unicode_trick' };
              // Block case-insensitive variations of dangerous paths
              const lower = filename.toLowerCase();
              if (lower.includes('.git/') || lower === '.git') return { valid: false, reason: 'git_folder' };
              if (lower.includes('node_modules/')) return { valid: false, reason: 'node_modules' };
              // Block executable extensions
              if (/\.(sh|bash|py|rb|pl|exe|bat|cmd|ps1|js|mjs|cjs|ts|php|jar|class)$/i.test(filename)) return { valid: false, reason: 'executable_file' };
              // Block config files that could be dangerous
              if (/^(\.env|\.npmrc|\.yarnrc|package\.json|package-lock\.json|yarn\.lock|Makefile|Dockerfile|docker-compose\.ya?ml)$/i.test(filename)) return { valid: false, reason: 'config_file' };
              return { valid: true };
            };
            
            const isAllowed = (filename) => 
              ALLOWED_PATTERNS.some(pattern => pattern.test(filename));
            
            // Check all files
            let blockedFiles = [];
            let allowedFiles = [];
            let securityViolations = [];
            
            for (const file of [...allAdded, ...allModified]) {
              const secCheck = normalizeAndValidate(file);
              if (!secCheck.valid) {
                securityViolations.push({ file, reason: secCheck.reason });
                continue;
              }
              
              if (isMaintainer || isBot) {
                allowedFiles.push(file);
              } else if (isAllowed(file)) {
                allowedFiles.push(file);
              } else {
                blockedFiles.push(file);
              }
            }
            
            // Export results
            core.exportVariable('PR_FILES_ADDED', allAdded.filter(f => allowedFiles.includes(f)).join(','));
            core.exportVariable('PR_FILES_MODIFIED', allModified.filter(f => allowedFiles.includes(f)).join(','));
            core.exportVariable('PR_FILES_REMOVED', removed.join(','));
            core.exportVariable('PR_FILES_BLOCKED', blockedFiles.join(','));
            core.exportVariable('PR_SECURITY_VIOLATIONS', JSON.stringify(securityViolations));
            core.exportVariable('PR_AUTHOR', prAuthor);
            core.exportVariable('PR_TITLE', context.payload.pull_request.title);
            core.exportVariable('PR_BODY', context.payload.pull_request.body || '');
            core.exportVariable('PR_IS_MAINTAINER', isMaintainer ? 'true' : 'false');
            core.exportVariable('PR_IS_BOT', isBot ? 'true' : 'false');
            
            // Set outputs for later steps
            core.setOutput('has_blocked_files', blockedFiles.length > 0 ? 'true' : 'false');
            core.setOutput('has_security_violations', securityViolations.length > 0 ? 'true' : 'false');
            core.setOutput('blocked_files', blockedFiles.join(', '));
            core.setOutput('security_violations', securityViolations.map(v => `${v.file} (${v.reason})`).join(', '));
            
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ“‹ FILE SECURITY CHECK');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ‘¤ Author:', prAuthor, isMaintainer ? '(MAINTAINER)' : isBot ? '(BOT)' : '');
            console.log('âœ… Allowed files:', allowedFiles.length > 0 ? allowedFiles : 'none');
            console.log('ğŸš« Blocked files:', blockedFiles.length > 0 ? blockedFiles : 'none');
            if (securityViolations.length > 0) {
              console.log('ğŸ”´ SECURITY VIOLATIONS:', securityViolations);
            }
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      
      - name: Security Gate
        if: steps.files.outputs.has_security_violations == 'true'
        run: |
          echo "ğŸ”´ SECURITY VIOLATION DETECTED!"
          echo "Violations: ${{ steps.files.outputs.security_violations }}"
          echo ""
          echo "This PR contains files that violate security rules:"
          echo "- Path traversal attempts (..)"
          echo "- Hidden files (starting with .)"
          echo "- Unicode tricks (zero-width characters)"
          echo "- Workflow modifications"
          echo "- Executable files"
          exit 1
      
      - name: Block Unauthorized Files
        if: steps.files.outputs.has_blocked_files == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const blockedFiles = '${{ steps.files.outputs.blocked_files }}';
            
            const comment = [
              '## ğŸš« Unauthorized Files Detected',
              '',
              'Your PR contains files outside the allowed contribution paths:',
              '',
              '**Blocked files:** `' + blockedFiles + '`',
              '',
              '### What\'s allowed?',
              'For **player contributions**, you can only add files matching:',
              '- `words/YOURWORD.txt` - Your word contribution',
              '',
              '### Why is this restricted?',
              'To prevent:',
              '- Malicious code injection',
              '- Overwriting game state files',
              '- Security vulnerabilities',
              '',
              '### How to fix?',
              '1. Remove the blocked files from your PR',
              '2. Keep only your word file in `words/` folder',
              '3. Push again',
              '',
              'If you believe this is an error, please open an issue.',
              '',
              '---',
              '_ğŸ›¡ï¸ Security check by enjoy-bot_'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
            
            // Add security label
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['security', 'blocked']
              });
            } catch (e) {
              console.log('Could not add labels:', e.message);
            }
            
            core.setFailed('PR contains unauthorized files. See comment for details.');
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # SECURITY GATE: All subsequent steps only run if NO security violations/blocks
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      - name: Validate PR Format
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        id: format
        uses: actions/github-script@v7
        with:
          script: |
            // Fetch PR body from API to ensure full content (event payload may be truncated)
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            // Normalize line endings (Windows \r\n -> Unix \n)
            const prBody = (pr.body || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            const prAuthor = pr.user.login || '';
            console.log('ğŸ“‹ PR Body length:', prBody.length);
            console.log('ğŸ“‹ PR Body preview:', prBody.substring(0, 500));

            const addedFiles = process.env.PR_FILES_ADDED || '';
            const modifiedFiles = process.env.PR_FILES_MODIFIED || '';
            const allFiles = `${addedFiles},${modifiedFiles}`.split(',').filter(f => f.trim());
            
            // EXPLICIT BOT LIST - These are NEVER counted as players
            const KNOWN_BOTS = [
              'github-actions[bot]',
              'dependabot[bot]',
              'dependabot',
              'actions-user',
              'renovate[bot]',
              'renovate',
              'codecov[bot]',
              'snyk-bot',
              'imgbot[bot]',
              'allcontributors[bot]',
              'copilot[bot]',
              'github-copilot[bot]'
            ];
            
            // Skip for bots (explicit list + pattern matching)
            const isBot = KNOWN_BOTS.includes(prAuthor) || 
                          prAuthor.includes('[bot]') || 
                          prAuthor.endsWith('-bot') ||
                          prAuthor.startsWith('bot-');
            
            if (isBot) {
              core.setOutput('valid_format', 'true');
              core.setOutput('skip_reason', 'bot_allowed');
              console.log('ğŸ¤– Bot detected:', prAuthor, '- skipping format check');
              return;
            }
            
            // Skip for documentation/meta PRs (not game contributions)
            const docPatterns = [
              /^README\.md$/i,
              /^README\..+\.md$/i,   // Translations
              /^LORE\.md$/i,
              /^CONTRIBUTING\.md$/i,
              /^bounties\.md$/i,
              /^LICENSE$/i,
              /^\.github\//,
              /^engine\//,
              /^docs\//,
              /^art\//,              // Auto-generated art
              /^badges\//,           // Auto-generated badges
              /^metrics\//,          // Auto-generated metrics
              /^index\.html$/,
              /^voice\.html$/,
              /^levels\/.*\.yaml$/
            ];
            
            const isDocPR = allFiles.length > 0 && allFiles.every(file => 
              docPatterns.some(pattern => pattern.test(file))
            );
            
            if (isDocPR) {
              core.setOutput('valid_format', 'true');
              core.setOutput('skip_reason', 'documentation_pr');
              console.log('ğŸ“š Documentation PR detected, skipping game format check');
              console.log('Files:', allFiles.join(', '));
              return;
            }
            
            const errors = [];
            const warnings = [];
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK 1: Guardian Question (Proof of Humanity)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const SACRED_ANSWERS = ['karmiel', 'KARMIEL', 'Karmiel'];
            const guardianMatch = prBody.match(/What is the name of the First Guardian\?\*?\*?\s*(.+?)(?:\n|---|$)/i);
            
            let guardianAnswer = '';
            if (guardianMatch && guardianMatch[1]) {
              guardianAnswer = guardianMatch[1].trim();
            }
            
            const hasGuardianAnswer = SACRED_ANSWERS.some(s => guardianAnswer.includes(s));
            if (!hasGuardianAnswer) {
              errors.push({
                field: 'Guardian Question',
                issue: 'Missing or wrong answer',
                hint: 'Read LORE.md to find the First Guardian name'
              });
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK 2: Word Field
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const wordMatch = prBody.match(/\*\*Word:\*\*\s*(.+?)(?:\n|$)/i);
            let word = '';
            if (wordMatch && wordMatch[1]) {
              word = wordMatch[1].trim();
            }
            
            if (!word || word === '' || word.includes('<!--')) {
              errors.push({
                field: 'Word',
                issue: 'Word field is empty',
                hint: 'Add your creative word after "**Word:**"'
              });
            } else if (word.length < 3) {
              errors.push({
                field: 'Word',
                issue: 'Word too short (min 3 chars)',
                hint: 'Choose a more substantial word'
              });
            } else if (word.length > 30) {
              errors.push({
                field: 'Word',
                issue: 'Word too long (max 30 chars)',
                hint: 'Keep it concise'
              });
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK 3: Checklist (at least 3 boxes checked)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const checkedBoxes = (prBody.match(/- \[x\]/gi) || []).length;
            const uncheckedBoxes = (prBody.match(/- \[ \]/g) || []).length;
            const totalBoxes = checkedBoxes + uncheckedBoxes;
            
            if (totalBoxes === 0) {
              errors.push({
                field: 'Checklist',
                issue: 'No checklist found',
                hint: 'Use the PR template with checkboxes'
              });
            } else if (checkedBoxes < 3) {
              errors.push({
                field: 'Checklist',
                issue: `Only ${checkedBoxes}/${totalBoxes} boxes checked`,
                hint: 'Read and check all requirements you meet'
              });
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK 4: Required sections exist
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const hasProofSection = prBody.includes('Proof of Humanity') || prBody.includes('First Guardian');
            const hasWordSection = prBody.includes('**Word:**') || prBody.includes('My Contribution');
            const hasChecklist = prBody.includes('Checklist') || prBody.includes('- [');
            
            if (!hasProofSection) {
              errors.push({
                field: 'Template',
                issue: 'Missing Proof of Humanity section',
                hint: 'Use the PR template provided'
              });
            }
            
            if (!hasWordSection) {
              errors.push({
                field: 'Template', 
                issue: 'Missing Word section',
                hint: 'Use the PR template provided'
              });
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // OUTPUT RESULTS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const isValid = errors.length === 0;
            
            core.setOutput('valid_format', isValid ? 'true' : 'false');
            core.setOutput('errors_count', errors.length.toString());
            core.setOutput('errors_json', JSON.stringify(errors));
            core.setOutput('word', word);
            core.setOutput('guardian_answer', guardianAnswer);
            core.setOutput('checked_boxes', checkedBoxes.toString());
            
            if (isValid) {
              console.log('âœ… PR Format is VALID');
              console.log('ğŸ“ Word:', word);
              console.log('ğŸ” Guardian:', guardianAnswer);
              console.log('â˜‘ï¸ Checkboxes:', checkedBoxes);
            } else {
              console.log('âŒ PR Format is INVALID');
              console.log('');
              errors.forEach((e, i) => {
                console.log(`${i+1}. [${e.field}] ${e.issue}`);
                console.log(`   ğŸ’¡ ${e.hint}`);
              });
            }

      - name: Setup Node.js
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        run: |
          cd engine
          npm ci
      
      - name: Build engine
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        run: |
          cd engine
          npm run build
      
      - name: Validate PR
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        id: validate
        run: |
          cd engine
          node dist/index.js validate --pr-number=${{ github.event.pull_request.number }}
        continue-on-error: true
      
      - name: Analyze Karma
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        id: karma
        run: |
          cd engine
          node -e "
            const fs = require('fs');
            const { loadState } = require('./dist/loader.js');
            const { analyzeContributionQuality } = require('./dist/karma.js');
            const { extractReferral } = require('./dist/validator.js');
            
            const state = loadState();
            let result = { valid: false };
            try {
              result = JSON.parse(fs.readFileSync('validation-result.json', 'utf8'));
            } catch(e) {}
            
            if (!result.valid) {
              fs.writeFileSync('karma-result.json', JSON.stringify({ skipped: true }));
              process.exit(0);
            }
            
            const addedFiles = (process.env.PR_FILES_ADDED || '').split(',').filter(f => f);
            let content = '';
            if (addedFiles.length > 0 && fs.existsSync(addedFiles[0])) {
              content = fs.readFileSync(addedFiles[0], 'utf8').trim();
            }
            
            const pr = {
              number: ${{ github.event.pull_request.number }},
              author: process.env.PR_AUTHOR || 'unknown',
              commit_message: process.env.PR_TITLE || '',
              files_added: addedFiles,
              timestamp: new Date().toISOString()
            };
            
            const karma = analyzeContributionQuality(pr, content, state);
            const referral = extractReferral(process.env.PR_BODY || '');
            
            const karmaResult = {
              quality_score: karma.quality_score,
              action: karma.action,
              amplification: karma.amplification_factor,
              referral: referral,
              reasons: karma.reasons
            };
            
            fs.writeFileSync('karma-result.json', JSON.stringify(karmaResult, null, 2));
            console.log('Karma:', JSON.stringify(karmaResult, null, 2));
          "
        continue-on-error: true
      
      - name: Read results
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        id: result
        run: |
          if [ -f engine/validation-result.json ]; then
            VALID=$(jq -r '.valid' engine/validation-result.json)
            REASON=$(jq -r '.reason // ""' engine/validation-result.json)
            RULES=$(jq -r '.matched_rules | join(", ")' engine/validation-result.json)
            POINTS=$(jq -r '.points' engine/validation-result.json)
            
            echo "valid=$VALID" >> $GITHUB_OUTPUT
            echo "reason=$REASON" >> $GITHUB_OUTPUT
            echo "rules=$RULES" >> $GITHUB_OUTPUT
            echo "points=$POINTS" >> $GITHUB_OUTPUT
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "reason=Validation failed to run" >> $GITHUB_OUTPUT
          fi
          
          if [ -f engine/karma-result.json ]; then
            KARMA_SCORE=$(jq -r '.quality_score // 0' engine/karma-result.json)
            KARMA_ACTION=$(jq -r '.action // "accept"' engine/karma-result.json)
            KARMA_AMP=$(jq -r '.amplification // 1' engine/karma-result.json)
            REFERRAL=$(jq -r '.referral // ""' engine/karma-result.json)
            
            echo "karma_score=$KARMA_SCORE" >> $GITHUB_OUTPUT
            echo "karma_action=$KARMA_ACTION" >> $GITHUB_OUTPUT
            echo "karma_amp=$KARMA_AMP" >> $GITHUB_OUTPUT
            echo "referral=$REFERRAL" >> $GITHUB_OUTPUT
          fi
      
      - name: Add labels
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const validFormat = '${{ steps.format.outputs.valid_format }}' === 'true';
            const valid = '${{ steps.result.outputs.valid }}' === 'true';
            const karmaAction = '${{ steps.result.outputs.karma_action }}';
            const karmaAmp = parseInt('${{ steps.result.outputs.karma_amp }}') || 1;
            
            const labelsToCreate = [
              { name: 'auto-merge', color: '0e8a16', description: 'Ready for auto-merge' },
              { name: 'invalid', color: 'd93f0b', description: 'Invalid contribution' },
              { name: 'karma-x2', color: 'fbca04', description: 'x2 amplification' },
              { name: 'karma-x3', color: 'b60205', description: 'x3 amplification' },
              { name: 'refused', color: '000000', description: 'Refused by karma' },
              { name: 'format-error', color: '5319e7', description: 'PR format is invalid' },
              { name: 'needs-fix', color: 'e99695', description: 'Needs changes to pass' }
            ];
            
            for (const label of labelsToCreate) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ...label
                });
              } catch (e) {}
            }
            
            try {
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              for (const label of labels) {
                if (['auto-merge', 'invalid', 'karma-x2', 'karma-x3', 'refused', 'format-error', 'needs-fix'].includes(label.name)) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    name: label.name
                  }).catch(() => {});
                }
              }
            } catch (e) {}
            
            const newLabels = [];
            
            if (!validFormat) {
              newLabels.push('format-error', 'needs-fix');
            } else if (karmaAction === 'refuse') {
              newLabels.push('refused', 'invalid');
            } else if (valid) {
              newLabels.push('auto-merge');
              if (karmaAmp === 2) newLabels.push('karma-x2');
              if (karmaAmp === 3) newLabels.push('karma-x3');
            } else {
              newLabels.push('invalid', 'needs-fix');
            }
            
            if (newLabels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: newLabels
              });
            }
      
      - name: Comment on PR
        if: steps.files.outputs.has_blocked_files != 'true' && steps.files.outputs.has_security_violations != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const validFormat = '${{ steps.format.outputs.valid_format }}' === 'true';
            const errorsJson = '${{ steps.format.outputs.errors_json }}';
            const valid = '${{ steps.result.outputs.valid }}' === 'true';
            const reason = `${{ steps.result.outputs.reason }}`;
            const rules = '${{ steps.result.outputs.rules }}';
            const points = '${{ steps.result.outputs.points }}';
            const karmaScore = '${{ steps.result.outputs.karma_score }}';
            const karmaAction = '${{ steps.result.outputs.karma_action }}';
            const karmaAmp = '${{ steps.result.outputs.karma_amp }}';
            const referral = '${{ steps.result.outputs.referral }}';
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ• TIME-BASED SYSTEM INTEGRATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const TIME_PERIODS = {
              dawn:      { start: 5,  end: 8,  emoji: 'ğŸŒ…', name: 'Dawn',      multiplier: 1.2,  mood: 'The early bird catches the karma' },
              morning:   { start: 8,  end: 12, emoji: 'â˜€ï¸', name: 'Morning',   multiplier: 1.3,  mood: 'Fresh minds, fresh code' },
              noon:      { start: 12, end: 15, emoji: 'ğŸŒ', name: 'Solar Peak',multiplier: 1.5,  mood: 'Maximum energy flow' },
              afternoon: { start: 15, end: 18, emoji: 'ğŸŒ¤ï¸', name: 'Afternoon', multiplier: 1.25, mood: 'Steady and focused' },
              sunset:    { start: 18, end: 21, emoji: 'ğŸŒ†', name: 'Sunset',    multiplier: 1.15, mood: 'Golden hour contributions' },
              night:     { start: 21, end: 5,  emoji: 'ğŸŒ™', name: 'Night',     multiplier: 1.4,  mood: 'Night owl bonus active' }
            };
            
            function getCETHour() {
              const now = new Date();
              const cetTime = new Date(now.toLocaleString("en-US", { timeZone: "Europe/Rome" }));
              return cetTime.getHours();
            }
            
            function getCurrentPeriod() {
              const hour = getCETHour();
              for (const [key, period] of Object.entries(TIME_PERIODS)) {
                if (key === 'night') {
                  if (hour >= 21 || hour < 5) return { key, ...period };
                } else if (hour >= period.start && hour < period.end) {
                  return { key, ...period };
                }
              }
              return { key: 'night', ...TIME_PERIODS.night };
            }
            
            function checkRareTimeEvent() {
              const now = new Date();
              const cetTime = new Date(now.toLocaleString("en-US", { timeZone: "Europe/Rome" }));
              const hours = cetTime.getHours();
              const minutes = cetTime.getMinutes();
              const timeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
              
              const events = {
                '00:00': { name: 'Witching Hour', bonus: 200, emoji: 'ğŸ”®' },
                '12:00': { name: 'Solar Peak', bonus: 100, emoji: 'â˜€ï¸' },
                '11:11': { name: 'Triple Time', bonus: 111, emoji: 'âœ¨' },
                '22:22': { name: 'Triple Time', bonus: 111, emoji: 'âœ¨' },
                '03:33': { name: "Devil's Hour", bonus: 333, emoji: 'ğŸ‘¹' }
              };
              
              return events[timeStr] || null;
            }
            
            const timePeriod = getCurrentPeriod();
            const rareEvent = checkRareTimeEvent();
            const cetHour = getCETHour();
            
            let body;
            
            // FIRST CHECK: PR Format
            if (!validFormat) {
              let errors = [];
              try {
                errors = JSON.parse(errorsJson);
              } catch(e) {}
              
              body = `## ğŸ“‹ PR Format Invalid\n\n`;
              body += `### ${timePeriod.emoji} Current Time: ${timePeriod.name} (CET)\n\n`;
              body += `Your PR doesn't follow the required format. Fix these issues:\n\n`;
              
              if (errors.length > 0) {
                body += `| # | Field | Issue | Hint |\n`;
                body += `|---|-------|-------|------|\n`;
                errors.forEach((e, i) => {
                  body += `| ${i+1} | **${e.field}** | ${e.issue} | ğŸ’¡ ${e.hint} |\n`;
                });
                body += `\n`;
              }
              
              body += `### How to fix:\n`;
              body += `1. Edit your PR description\n`;
              body += `2. Use the [PR template](../blob/main/.github/PULL_REQUEST_TEMPLATE.md)\n`;
              body += `3. Fill in ALL required fields\n`;
              body += `4. Check the boxes for requirements you meet\n\n`;
              body += `> *"The format is the ritual. The ritual is the game."*\n\n`;
              body += `ğŸ’¡ **Tip:** Fix now while the **x${timePeriod.multiplier} ${timePeriod.name} bonus** is active!\n\n`;
              body += `---\n_Enjoy and contribute!_ âœ¨`;
            } else if (karmaAction === 'refuse') {
              body = `## âŒ Contribution Refused\n\n`;
              body += `### ${timePeriod.emoji} ${timePeriod.name} Mode\n\n`;
              body += `**Karma Score:** ${karmaScore}/100\n`;
              body += `**Reason:** Low quality contribution.\n\n`;
              body += `**Tips to improve:**\n`;
              body += `- Use creative words (5-10 chars)\n`;
              body += `- Avoid "test", "hello", "foo"\n`;
              body += `- No duplicates\n\n`;
              body += `ğŸ’¡ The **x${timePeriod.multiplier} ${timePeriod.name} bonus** is waiting for quality!\n\n`;
              body += `---\n_Enjoy and contribute!_`;
            } else if (valid) {
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // âœ… VALID CONTRIBUTION - Show time bonuses!
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              body = `## âœ… Valid Contribution!\n\n`;
              
              // Time banner
              body += `### ${timePeriod.emoji} ${timePeriod.name} Mode Active\n`;
              body += `> *"${timePeriod.mood}"*\n\n`;
              
              body += `| Metric | Value |\n`;
              body += `|--------|-------|\n`;
              body += `| **Rules** | ${rules} |\n`;
              body += `| **Base Points** | +${points} |\n`;
              body += `| **Karma Quality** | ${karmaScore}/100 |\n`;
              body += `| **Time Period** | ${timePeriod.emoji} ${timePeriod.name} (CET ${cetHour}:00) |\n`;
              body += `| **Time Multiplier** | x${timePeriod.multiplier} |\n`;
              
              if (karmaAmp === '3') {
                body += `| **Quality Amplifier** | ğŸŒŸ LEGENDARY x3 |\n`;
              } else if (karmaAmp === '2') {
                body += `| **Quality Amplifier** | âœ¨ Excellent x2 |\n`;
              }
              
              body += `\n`;
              
              // Rare event alert
              if (rareEvent) {
                body += `### ${rareEvent.emoji} RARE EVENT: ${rareEvent.name}!\n`;
                body += `> **+${rareEvent.bonus} bonus karma** for perfect timing!\n\n`;
              }
              
              // Time-based achievements preview
              if (cetHour >= 21 || cetHour < 5) {
                body += `ğŸ¦‰ **Night Owl Badge** - Contributing during the night!\n`;
              } else if (cetHour >= 5 && cetHour < 8) {
                body += `ğŸ¦ **Early Bird Badge** - First light contributor!\n`;
              } else if (cetHour >= 12 && cetHour < 15) {
                body += `â˜€ï¸ **Solar Peak Badge** - Maximum energy contribution!\n`;
              }
              
              if (referral && referral !== 'null') {
                body += `\n**Referred by:** @${referral} ğŸ¤\n`;
              }
              
              body += `\n---\n`;
              body += `â° **Upon merge:** Your karma will be multiplied by **x${timePeriod.multiplier}** (${timePeriod.name} bonus)\n\n`;
              body += `Auto-merging shortly! ğŸ‰\n\n---\n_Enjoy and contribute!_ âœ¨`;
            } else {
              body = `## âŒ Invalid Contribution\n\n`;
              body += `### ${timePeriod.emoji} ${timePeriod.name} Mode\n\n`;
              body += `**Reason:** ${reason}\n\n`;
              body += `ğŸ’¡ Fix and try again - **x${timePeriod.multiplier} ${timePeriod.name} bonus** is waiting!\n\n`;
              body += `---\n_Enjoy and contribute!_`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
      
      - name: Fail if format invalid
        if: steps.format.outputs.valid_format != 'true'
        run: |
          echo "ğŸ“‹ PR Format validation failed!"
          echo "Please edit your PR to follow the required format."
          echo ""
          echo "Required fields:"
          echo "  - Guardian Question (Proof of Humanity)"
          echo "  - Word field"
          echo "  - Checklist (at least 3 boxes checked)"
          exit 1
