name: Update State on Merge

on:
  pull_request:
    types: [closed]

concurrency:
  group: enjoy-game-state
  cancel-in-progress: false

jobs:
  update-state:
    if: github.event.pull_request.merged == true
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SECURITY NOTE: PAT on ubuntu-latest is SAFE here because:
    # 1. This only runs AFTER PR is merged (pull_request: closed + merged == true)
    # 2. We checkout 'main' branch, NOT the PR branch
    # 3. The workflow YAML comes from main, not from the PR
    # 4. The PAT is needed to: a) push commits b) trigger downstream workflows
    # DO NOT change this to checkout the PR branch or run PR code!
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Configure git
        run: |
          git config user.name "enjoy-bot"
          git config user.email "bot@enjoy.game"
      
      - name: Update state
        env:
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_CREATED: ${{ github.event.pull_request.created_at }}
          PR_MERGED: ${{ github.event.pull_request.merged_at }}
        run: |
          node --input-type=module -e "
            import { readFileSync, writeFileSync } from 'fs';
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TIME-BASED SYSTEM (CET/GMT+1)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const TIME_PERIODS = {
              dawn: { hours: [5,6,7], emoji: 'ğŸŒ…', name: 'Dawn', mult: 1.2 },
              morning: { hours: [8,9,10,11], emoji: 'â˜€ï¸', name: 'Morning', mult: 1.3 },
              noon: { hours: [12,13,14], emoji: 'ğŸŒ', name: 'Noon', mult: 1.5 },
              afternoon: { hours: [15,16,17], emoji: 'ğŸŒ¤ï¸', name: 'Afternoon', mult: 1.25 },
              sunset: { hours: [18,19,20], emoji: 'ğŸŒ…', name: 'Sunset', mult: 1.15 },
              night: { hours: [21,22,23,0,1,2,3,4], emoji: 'ğŸŒ™', name: 'Night', mult: 1.4 }
            };
            
            function getCETTime() {
              const now = new Date();
              const cetHour = (now.getUTCHours() + 1) % 24;
              const cetMinute = now.getUTCMinutes();
              return { hour: cetHour, minute: cetMinute };
            }
            
            function getCurrentPeriod() {
              const { hour } = getCETTime();
              for (const [id, cfg] of Object.entries(TIME_PERIODS)) {
                if (cfg.hours.includes(hour)) return { id, ...cfg };
              }
              return { id: 'night', ...TIME_PERIODS.night };
            }
            
            function checkRareTimeEvents() {
              const { hour, minute } = getCETTime();
              const events = [];
              
              // Midnight exact
              if (hour === 0 && minute === 0) {
                events.push({ id: 'witching_hour', name: 'Witching Hour', bonus: 200, emoji: 'ğŸ•›' });
              }
              // Noon exact
              if (hour === 12 && minute === 0) {
                events.push({ id: 'solar_peak', name: 'Solar Peak', bonus: 100, emoji: 'â˜€ï¸' });
              }
              // 11:11 or 22:22
              if ((hour === 11 && minute === 11) || (hour === 22 && minute === 22)) {
                events.push({ id: 'triple_time', name: 'Time Aligned', bonus: 111, emoji: 'â°' });
              }
              // 3:33 AM (spooky)
              if (hour === 3 && minute === 33) {
                events.push({ id: 'devils_hour', name: \"Devil's Hour\", bonus: 333, emoji: 'ğŸ‘¹' });
              }
              
              return events;
            }
            
            function getTimeGreeting(username, period) {
              const greetings = {
                dawn: ['ğŸŒ… Early bird ' + username + '! Dawn rewards the dedicated.', 'ğŸŒ… ' + username + ' rises with the sun.'],
                morning: ['â˜€ï¸ Good morning ' + username + '! Fresh code for a fresh day.', 'â˜€ï¸ ' + username + ' brings morning energy.'],
                noon: ['ğŸŒ ' + username + ' strikes at peak power!', 'ğŸŒ Solar alignment achieved, ' + username + '.'],
                afternoon: ['ğŸŒ¤ï¸ Golden afternoon, ' + username + '.', 'ğŸŒ¤ï¸ ' + username + ' catches the golden hour.'],
                sunset: ['ğŸŒ… ' + username + ' harvests the sunset light.', 'ğŸŒ… Sunset contributor ' + username + '.'],
                night: ['ğŸŒ™ Night owl ' + username + '!', 'ğŸŒ™ ' + username + ' codes while others sleep.']
              };
              const g = greetings[period.id] || greetings.night;
              return g[Math.floor(Math.random() * g.length)];
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DAILY CHALLENGES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const DAILY_CHALLENGES = [
              { id: 'seven_letters', check: (w) => w.length === 7, mult: 2 },
              { id: 'starts_with_vowel', check: (w) => /^[aeiou]/i.test(w), mult: 1.5 },
              { id: 'nature_word', check: (w) => ['sun','moon','star','tree','river','ocean','mountain','forest','wind','rain','flower','earth','sky','cloud','leaf'].some(n => w.toLowerCase().includes(n)), mult: 2 },
              { id: 'double_letter', check: (w) => /(.)\1/.test(w), mult: 1.5 },
              { id: 'palindrome', check: (w) => { const c = w.toLowerCase(); return c === c.split('').reverse().join('') && c.length >= 3; }, mult: 3 },
              { id: 'no_e', check: (w) => !/e/i.test(w) && w.length >= 5, mult: 1.5 },
              { id: 'ten_plus', check: (w) => w.length >= 10, mult: 2 }
            ];
            
            function getTodayChallenge() {
              const dayOfYear = Math.floor((Date.now() - new Date(new Date().getFullYear(), 0, 0).getTime()) / 86400000);
              return DAILY_CHALLENGES[dayOfYear % DAILY_CHALLENGES.length];
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // STREAK SYSTEM  
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function getStreakMultiplier(days) {
              if (days >= 30) return 3.0;
              if (days >= 14) return 2.5;
              if (days >= 7) return 2.0;
              if (days >= 3) return 1.5;
              return 1.0;
            }
            
            function updateStreak(player) {
              const now = new Date();
              const last = player.last_contribution ? new Date(player.last_contribution) : null;
              
              if (!last) return 1;
              
              const diffDays = Math.floor((now - last) / 86400000);
              if (diffDays === 0) return player.streak || 1;
              if (diffDays === 1) return (player.streak || 0) + 1;
              return 1; // Streak broken
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MYSTERY BOX
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const MYSTERY_REWARDS = [
              { type: 'karma', value: 10, name: 'Small Boost', emoji: 'ğŸ’«' },
              { type: 'karma', value: 25, name: 'Medium Boost', emoji: 'âœ¨' },
              { type: 'karma', value: 50, name: 'Large Boost', emoji: 'ğŸŒŸ' },
              { type: 'karma', value: 100, name: 'JACKPOT!', emoji: 'ğŸ°' }
            ];
            
            function rollMysteryBox() {
              const weights = [40, 35, 20, 5];
              const total = weights.reduce((a,b) => a+b, 0);
              let r = Math.random() * total;
              for (let i = 0; i < weights.length; i++) {
                r -= weights[i];
                if (r <= 0) return MYSTERY_REWARDS[i];
              }
              return MYSTERY_REWARDS[0];
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ACHIEVEMENTS (includes time-based)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function checkAchievements(player, state, context) {
              const earned = player.achievements || [];
              const newAch = [];
              const period = context.period;
              const timeStats = player.time_stats || {};
              
              const checks = [
                { id: 'first_blood', karma: 10, check: () => player.prs >= 1 },
                { id: 'getting_started', karma: 25, check: () => player.prs >= 5 },
                { id: 'dedicated', karma: 100, check: () => player.prs >= 25 },
                { id: 'legend', karma: 500, check: () => player.prs >= 100 },
                { id: 'karma_hunter', karma: 20, check: () => player.karma >= 100 },
                { id: 'karma_master', karma: 75, check: () => player.karma >= 500 },
                { id: 'karma_god', karma: 200, check: () => player.karma >= 1000 },
                { id: 'streak_3', karma: 15, check: () => (player.streak || 0) >= 3 },
                { id: 'streak_7', karma: 50, check: () => (player.streak || 0) >= 7 },
                { id: 'streak_30', karma: 300, check: () => (player.streak || 0) >= 30 },
                { id: 'recruiter', karma: 25, check: () => (player.referrals || 0) >= 1 },
                { id: 'influencer', karma: 100, check: () => (player.referrals || 0) >= 5 },
                { id: 'viral', karma: 500, check: () => (player.referrals || 0) >= 20 },
                { id: 'wordsmith', karma: 30, check: () => context.baseKarma >= 80 },
                { id: 'og', karma: 100, check: () => Object.keys(state.players).indexOf(player.name) < 10 },
                { id: 'speed_demon', karma: 25, check: () => context.mergeTimeSeconds < 60 },
                { id: 'centurion', karma: 200, check: () => Object.keys(state.players).length === 100 },
                // TIME-BASED ACHIEVEMENTS
                { id: 'night_owl', karma: 25, check: () => period.id === 'night' && (timeStats.night || 0) >= 5 },
                { id: 'early_bird', karma: 25, check: () => period.id === 'dawn' && (timeStats.dawn || 0) >= 3 },
                { id: 'noon_master', karma: 50, check: () => period.id === 'noon' && (timeStats.noon || 0) >= 10 },
                { id: 'golden_contributor', karma: 30, check: () => period.id === 'afternoon' && (timeStats.afternoon || 0) >= 5 },
                { id: 'sunset_harvester', karma: 30, check: () => period.id === 'sunset' && (timeStats.sunset || 0) >= 5 },
                { id: 'morning_person', karma: 30, check: () => period.id === 'morning' && (timeStats.morning || 0) >= 10 },
                { id: 'around_the_clock', karma: 200, check: () => {
                  return ['dawn','morning','noon','afternoon','sunset','night'].every(p => (timeStats[p] || 0) >= 1);
                }},
                { id: 'midnight_coder', karma: 100, check: () => context.rareEvents.some(e => e.id === 'witching_hour') },
                { id: 'solar_aligned', karma: 75, check: () => context.rareEvents.some(e => e.id === 'solar_peak') },
                { id: 'time_master', karma: 150, check: () => context.rareEvents.some(e => e.id === 'triple_time') }
              ];
              
              for (const ach of checks) {
                if (!earned.includes(ach.id) && ach.check()) {
                  newAch.push(ach);
                }
              }
              
              return newAch;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MAIN LOGIC
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const state = JSON.parse(readFileSync('./state.json', 'utf8'));
            
            const author = process.env.PR_AUTHOR || 'unknown';
            const prNumber = parseInt(process.env.PR_NUMBER) || 0;
            const prTitle = process.env.PR_TITLE || '';
            const prBody = process.env.PR_BODY || '';
            const prCreated = new Date(process.env.PR_CREATED);
            const prMerged = new Date(process.env.PR_MERGED);
            const mergeTimeSeconds = Math.floor((prMerged - prCreated) / 1000);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BOT DETECTION - Never count bots as players!
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const KNOWN_BOTS = [
              'github-actions[bot]', 'dependabot[bot]', 'dependabot',
              'actions-user', 'renovate[bot]', 'renovate', 'codecov[bot]',
              'snyk-bot', 'imgbot[bot]', 'allcontributors[bot]',
              'copilot[bot]', 'github-copilot[bot]'
            ];
            
            const isBot = KNOWN_BOTS.includes(author) || 
                          author.includes('[bot]') || 
                          author.endsWith('-bot') ||
                          author.startsWith('bot-');
            
            if (isBot) {
              console.log('ğŸ¤– Bot detected:', author, '- skipping karma calculation');
              console.log('Bots do not earn karma or appear on leaderboard.');
              process.exit(0);
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TRANSLATION CHECK - Handled by translation-karma.yml
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Translation PRs are handled by a dedicated workflow to avoid double-counting
            const isTranslation = /^(README|QUICKSTART|CONTRIBUTING|MANIFESTO|PLAY)\.[a-z]{2}\.md$/i.test(prTitle) ||
                                  prTitle.toLowerCase().includes('translation') ||
                                  prTitle.toLowerCase().includes('translate') ||
                                  prTitle.match(/ğŸŒ|ğŸ‡ªğŸ‡¸|ğŸ‡«ğŸ‡·|ğŸ‡©ğŸ‡ª|ğŸ‡®ğŸ‡¹|ğŸ‡µğŸ‡¹|ğŸ‡¯ğŸ‡µ|ğŸ‡¨ğŸ‡³|ğŸ‡°ğŸ‡·|ğŸ‡·ğŸ‡º/);
            
            if (isTranslation) {
              console.log('ğŸŒ Translation PR detected - karma handled by translation-karma.yml');
              console.log('Skipping to avoid double-counting karma.');
              process.exit(0);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AUTO-MERGE CHECK - Already handled by auto-merge.yml
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const prLabels = '${{ join(github.event.pull_request.labels.*.name, ',') }}';
            const wasAutoMerged = prLabels.includes('auto-merge');

            if (wasAutoMerged) {
              console.log('â­ï¸ Auto-merged PR detected - karma already calculated by auto-merge.yml');
              console.log('Skipping to avoid double-counting karma.');
              process.exit(0);
            }

            // Extract word from PR title (format: 'Add word: xyz')
            const wordMatch = prTitle.match(/add\\s+word[:\\s]+([a-zA-Z]+)/i);
            const word = wordMatch ? wordMatch[1] : '';
            
            // Base karma
            let baseKarma = 10;
            
            // Initialize player if new
            const isNewPlayer = !state.players[author];
            if (isNewPlayer) {
              state.players[author] = {
                karma: 0,
                prs: 0,
                streak: 0,
                achievements: [],
                joined: new Date().toISOString()
              };
              state.meta.total_players++;
              console.log('ğŸ†• New player:', author);
            }
            
            const player = state.players[author];
            player.name = author; // For achievement checks
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TIME SYSTEM - Calculate period and bonuses
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const period = getCurrentPeriod();
            const timeMultiplier = period.mult;
            let rareEvents = checkRareTimeEvents();
            const timeGreeting = getTimeGreeting(author, period);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RARE EVENT COOLDOWN - Prevent farming (max 1 per 24h per player)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (rareEvents.length > 0) {
              const lastRareEvent = player.last_rare_event ? new Date(player.last_rare_event).getTime() : 0;
              const hoursSinceLastEvent = (Date.now() - lastRareEvent) / (1000 * 3600);

              if (hoursSinceLastEvent < 24) {
                console.log('â³ Rare event cooldown active (' + Math.round(24 - hoursSinceLastEvent) + 'h remaining) - bonus skipped');
                rareEvents = []; // Clear bonus to prevent farming
              } else {
                player.last_rare_event = new Date().toISOString();
                console.log('ğŸ‰ Rare event bonus applied! Next available in 24h.');
              }
            }
            
            // Track time stats for achievements
            player.time_stats = player.time_stats || {};
            player.time_stats[period.id] = (player.time_stats[period.id] || 0) + 1;
            
            console.log(period.emoji + ' Time Period: ' + period.name + ' (x' + timeMultiplier + ' bonus)');
            if (rareEvents.length > 0) {
              rareEvents.forEach(e => console.log(e.emoji + ' RARE EVENT: ' + e.name + ' (+' + e.bonus + ' karma!)'));
            }
            
            // Update streak
            const newStreak = updateStreak(player);
            const streakMultiplier = getStreakMultiplier(newStreak);
            player.streak = newStreak;
            player.last_contribution = new Date().toISOString();
            
            // Check daily challenge
            let challengeMultiplier = 1;
            let challengeCompleted = false;
            if (word) {
              const challenge = getTodayChallenge();
              if (challenge.check(word)) {
                challengeMultiplier = challenge.mult;
                challengeCompleted = true;
                console.log('ğŸ¯ Daily challenge completed! x' + challengeMultiplier);
              }
            }
            
            // Calculate karma with ALL multipliers (base * streak * challenge * time)
            // BALANCE: Cap combined multiplier at 4x to prevent extreme stacking exploits
            const combinedMultiplier = streakMultiplier * challengeMultiplier * timeMultiplier;
            const cappedMultiplier = Math.min(4.0, combinedMultiplier);
            if (combinedMultiplier > 4.0) {
              console.log('âš–ï¸ Multiplier capped: ' + combinedMultiplier.toFixed(2) + 'x â†’ 4.0x');
            }
            let totalKarma = Math.round(baseKarma * cappedMultiplier);
            
            // Add rare time event bonuses
            for (const event of rareEvents) {
              totalKarma += event.bonus;
              console.log(event.emoji + ' Rare Event Bonus: +' + event.bonus + ' karma');
            }
            
            // Mystery Box check (every 5 contributions)
            const totalContribs = (player.prs || 0) + 1;
            let mysteryReward = null;
            if (totalContribs % 5 === 0) {
              mysteryReward = rollMysteryBox();
              totalKarma += mysteryReward.value;
              console.log('ğŸ Mystery Box: ' + mysteryReward.emoji + ' ' + mysteryReward.name + ' (+' + mysteryReward.value + ' karma)');
            }
            
            // Update player stats before achievement check
            player.prs++;
            player.karma += totalKarma;
            state.meta.total_prs++;
            
            // Check achievements (with time context)
            const context = { baseKarma, mergeTimeSeconds, period, rareEvents };
            const newAchievements = checkAchievements(player, state, context);
            for (const ach of newAchievements) {
              player.achievements = player.achievements || [];
              player.achievements.push(ach.id);
              player.karma += ach.karma;
              totalKarma += ach.karma;
              console.log('ğŸ† Achievement unlocked: ' + ach.id + ' (+' + ach.karma + ' karma)');
            }
            
            // Update global state
            state.last_updated = new Date().toISOString();
            state.last_pr = '#' + prNumber;
            state.score.total += totalKarma;
            state.score.today += totalKarma;
            
            // Update TIME SYSTEM stats
            if (!state.time_system) {
              state.time_system = {
                current_period: period.id,
                last_update: new Date().toISOString(),
                stats: {},
                rare_events_triggered: [],
                most_active_period: null
              };
            }
            state.time_system.current_period = period.id;
            state.time_system.last_update = new Date().toISOString();
            if (!state.time_system.stats[period.id]) {
              state.time_system.stats[period.id] = { total_prs: 0, total_karma: 0 };
            }
            state.time_system.stats[period.id].total_prs++;
            state.time_system.stats[period.id].total_karma += totalKarma;
            
            // Track rare events
            for (const event of rareEvents) {
              state.time_system.rare_events_triggered.push({
                id: event.id,
                name: event.name,
                player: author,
                timestamp: new Date().toISOString()
              });
            }
            
            // Determine most active period
            let maxPrs = 0;
            let mostActive = null;
            for (const [pid, pstats] of Object.entries(state.time_system.stats)) {
              if (pstats.total_prs > maxPrs) {
                maxPrs = pstats.total_prs;
                mostActive = pid;
              }
            }
            state.time_system.most_active_period = mostActive;
            
            // Track streak in global score
            if (newStreak > (state.score.streak_days || 0)) {
              state.score.streak_days = newStreak;
            }
            
            // Check level progress
            if (state.levels.next_unlock) {
              state.levels.next_unlock.progress.score = state.score.total;
              state.levels.next_unlock.progress.prs = state.meta.total_prs;
              
              const next = state.levels.next_unlock;
              const needsScore = next.progress.score >= next.requires_score;
              const needsPrs = next.progress.prs >= next.requires_prs;
              
              if (needsScore && needsPrs) {
                console.log('ğŸ‰ LEVEL UP! Unlocking level', next.level_id);
                state.levels.current = next.level_id;
                state.levels.unlocked.push(next.level_id);
                
                if (next.level_id < 100) {
                  state.levels.next_unlock = {
                    level_id: next.level_id + 1,
                    requires_score: Math.floor(next.requires_score * 1.5),
                    requires_prs: next.requires_prs + 3,
                    progress: { score: state.score.total, prs: state.meta.total_prs }
                  };
                } else {
                  state.levels.next_unlock = null;
                  console.log('ğŸ† MAX LEVEL 100 REACHED!');
                }
              }
            }
            
            // Summary
            console.log('');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ“Š CONTRIBUTION SUMMARY');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log(timeGreeting);
            console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
            console.log('Player:', author);
            console.log('Word:', word || '(not detected)');
            console.log('Base karma:', baseKarma);
            console.log(period.emoji + ' Time:', period.name, '(x' + timeMultiplier + ')');
            console.log('Streak:', newStreak, 'days (x' + streakMultiplier + ')');
            console.log('Challenge:', challengeCompleted ? 'âœ… Complete (x' + challengeMultiplier + ')' : 'â€”');
            console.log('Rare Events:', rareEvents.length > 0 ? rareEvents.map(e => e.emoji + e.name).join(', ') : 'â€”');
            console.log('Mystery Box:', mysteryReward ? mysteryReward.emoji + ' +' + mysteryReward.value : 'â€”');
            console.log('New Achievements:', newAchievements.length || 'â€”');
            console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
            console.log('TOTAL KARMA:', totalKarma);
            console.log('Player karma:', player.karma);
            console.log('Player streak:', player.streak);
            console.log('Time stats:', JSON.stringify(player.time_stats));
            console.log('Game score:', state.score.total, '| Level:', state.levels.current);
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            writeFileSync('./state.json', JSON.stringify(state, null, 2));
          "
      
      - name: Commit and push
        run: |
          git add state.json
          if git diff --staged --quiet; then
            echo "::notice::No changes to commit"
          else
            git commit -m "ğŸ“Š State update from PR #${{ github.event.pull_request.number }} [skip ci]"
            if ! git push; then
              echo "::warning::Push failed - may require manual sync or retry"
              exit 1
            fi
          fi
