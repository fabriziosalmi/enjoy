<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>enjoy</title>
    <meta name="description" content="A living organism. 100 levels. Contribute to evolve.">
    <meta property="og:title" content="enjoy">
    <meta property="og:description" content="The repo breathes. The game evolves. Join the organism.">
    <meta property="og:image" content="https://fabriziosalmi.github.io/enjoy/og-image.png">
    <meta property="og:url" content="https://fabriziosalmi.github.io/enjoy/">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500&family=JetBrains+Mono:wght@300&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050508;
            --surface: rgba(255,255,255,0.02);
            --border: rgba(255,255,255,0.06);
            --text: rgba(255,255,255,0.87);
            --text-muted: rgba(255,255,255,0.4);
            --accent: #6366f1;
            --glow: rgba(99, 102, 241, 0.15);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-weight: 300;
            background: var(--bg);
            color: var(--text);
            letter-spacing: 0.01em;
            display: flex;
            flex-direction: column;
        }
        
        /* ═══════════════════════════════════════════════════════════════
           ORGANIC LAYERS
           ═══════════════════════════════════════════════════════════════ */
        
        .grain {
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            pointer-events: none;
            opacity: 0.03;
            z-index: 1000;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            animation: grain 0.5s steps(1) infinite;
        }
        
        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-1%, -1%); }
            20% { transform: translate(1%, 1%); }
            30% { transform: translate(-1%, 1%); }
            40% { transform: translate(1%, -1%); }
            50% { transform: translate(-1%, 0); }
            60% { transform: translate(1%, 0); }
            70% { transform: translate(0, 1%); }
            80% { transform: translate(0, -1%); }
            90% { transform: translate(1%, 1%); }
        }
        
        .breath {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 120vmax;
            height: 120vmax;
            transform: translate(-50%, -50%);
            pointer-events: none;
            background: radial-gradient(circle, var(--glow) 0%, transparent 60%);
            animation: breathe 8s ease-in-out infinite;
            z-index: -1;
        }
        
        @keyframes breathe {
            0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.7; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        .vignette {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(0,0,0,0.5) 100%);
            z-index: 999;
        }
        
        /* ═══════════════════════════════════════════════════════════════
           MAIN LAYOUT - No scroll, fills viewport
           ═══════════════════════════════════════════════════════════════ */
        
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            position: relative;
            z-index: 1;
            max-height: 100vh;
            max-height: 100dvh;
        }
        
        /* Header removed - more space for the organism */
        
        /* ═══════════════════════════════════════════════════════════════
           ORGANISM - The living canvas
           ═══════════════════════════════════════════════════════════════ */
        
        .organism {
            position: relative;
            width: 100%;
            max-width: 900px;
            flex: 1;
            min-height: 250px;
            max-height: 55vh;
            margin: 1.5rem 0;
            border-radius: 1.5rem;
            overflow: hidden;
            background: var(--surface);
            border: 1px solid var(--border);
        }
        
        #canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }
        
        /* ═══════════════════════════════════════════════════════════════
           DATA
           ═══════════════════════════════════════════════════════════════ */
        
        .data {
            display: flex;
            justify-content: center;
            gap: clamp(1rem, 4vw, 2rem);
            flex-shrink: 0;
        }
        
        .datum {
            text-align: center;
            padding: 1rem 1.5rem;
            background: rgba(0,0,0,0.4);
            border-radius: 1rem;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            box-shadow: 0 0 30px rgba(99, 102, 241, 0.08);
            position: relative;
            overflow: hidden;
        }
        
        /* Subtle random light pulse on data cards */
        .datum::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(
                circle at var(--glow-x, 50%) var(--glow-y, 50%),
                rgba(99, 102, 241, var(--glow-opacity, 0)) 0%,
                transparent 60%
            );
            pointer-events: none;
            transition: opacity 0.8s ease;
        }
        
        .datum-value {
            font-size: clamp(1.3rem, 4vw, 2rem);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 300;
            color: var(--text);
            position: relative;
            text-shadow: 0 0 20px rgba(99, 102, 241, var(--text-glow, 0));
            transition: text-shadow 0.5s ease;
        }
        
        .datum-label {
            font-size: clamp(0.45rem, 1.2vw, 0.6rem);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-top: 0.3rem;
            position: relative;
        }
        
        /* ═══════════════════════════════════════════════════════════════
           PROGRESS
           ═══════════════════════════════════════════════════════════════ */
        
        .progress {
            width: 100%;
            max-width: 300px;
            margin: 1.5rem 0;
            text-align: center;
            flex-shrink: 0;
        }
        
        .progress-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 0.5rem;
        }
        
        .progress-track {
            height: 2px;
            background: var(--border);
            border-radius: 1px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 1s ease;
            box-shadow: 0 0 15px var(--glow);
        }
        
        /* ═══════════════════════════════════════════════════════════════
           CTA - Organic beckoning button
           ═══════════════════════════════════════════════════════════════ */
        
        .cta {
            flex-shrink: 0;
            margin: 1rem 0;
            position: relative;
        }
        
        .cta a {
            display: inline-block;
            padding: 1.2rem 4rem;
            color: var(--text);
            text-decoration: none;
            font-size: 1rem;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            border: 1px solid var(--border);
            border-radius: 100px;
            transition: all 0.4s ease;
            position: relative;
            filter: blur(var(--cta-blur, 0px));
            transform: scale(var(--cta-scale, 1));
        }
        
        .cta a:hover {
            border-color: var(--accent);
            box-shadow: 0 0 40px var(--glow);
        }
        
        /* Beckoning state */
        .cta.beckoning a {
            animation: beckon 2s ease-in-out;
        }
        
        @keyframes beckon {
            0% {
                filter: blur(0px);
                transform: scale(1);
                border-color: var(--border);
                box-shadow: 0 0 0 rgba(99, 102, 241, 0);
            }
            15% {
                filter: blur(1px);
                transform: scale(1.02);
            }
            30% {
                filter: blur(0px);
                transform: scale(1.05);
                border-color: rgba(139, 92, 246, 0.6);
                box-shadow: 0 0 50px rgba(139, 92, 246, 0.3);
            }
            45% {
                filter: blur(0.5px);
                transform: scale(1.03);
            }
            60% {
                filter: blur(0px);
                transform: scale(1.04);
                border-color: rgba(167, 139, 250, 0.5);
                box-shadow: 0 0 60px rgba(139, 92, 246, 0.25);
            }
            80% {
                transform: scale(1.02);
            }
            100% {
                filter: blur(0px);
                transform: scale(1);
                border-color: var(--border);
                box-shadow: 0 0 0 rgba(99, 102, 241, 0);
            }
        }
        
        /* ═══════════════════════════════════════════════════════════════
           FOOTER
           ═══════════════════════════════════════════════════════════════ */
        
        footer {
            flex-shrink: 0;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.65rem;
            letter-spacing: 0.15em;
            margin-top: 0.5rem;
        }
        
        footer a {
            color: var(--text-muted);
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        footer a:hover {
            color: var(--text);
        }
        
        /* ═══════════════════════════════════════════════════════════════
           LIVE INDICATOR
           ═══════════════════════════════════════════════════════════════ */
        
        .live {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.55rem;
            color: var(--text-muted);
            letter-spacing: 0.2em;
            text-transform: uppercase;
            z-index: 100;
        }
        
        .live-dot {
            width: 5px;
            height: 5px;
            background: var(--accent);
            border-radius: 50%;
            animation: pulse-dot 2s ease-in-out infinite;
        }
        
        @keyframes pulse-dot {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
        
        /* ═══════════════════════════════════════════════════════════════
           AUDIO TOGGLE
           ═══════════════════════════════════════════════════════════════ */
        
        .audio-toggle {
            position: fixed;
            bottom: 1.5rem;
            left: 1.5rem;
            width: 36px;
            height: 36px;
            background: rgba(0,0,0,0.4);
            border: 1px solid var(--border);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .audio-toggle:hover {
            background: rgba(99, 102, 241, 0.1);
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .audio-toggle svg {
            width: 16px;
            height: 16px;
            fill: var(--text-muted);
            transition: fill 0.3s ease;
        }
        
        .audio-toggle:hover svg {
            fill: var(--text);
        }
        
        .audio-toggle.active svg {
            fill: var(--accent);
        }
        
        .audio-toggle .icon-off {
            display: block;
        }
        
        .audio-toggle .icon-on {
            display: none;
        }
        
        .audio-toggle.active .icon-off {
            display: none;
        }
        
        .audio-toggle.active .icon-on {
            display: block;
        }
        
        /* ═══════════════════════════════════════════════════════════════
           FLASH OVERLAY
           ═══════════════════════════════════════════════════════════════ */
        
        .flash-overlay {
            position: fixed;
            inset: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
            transition: opacity 0.1s ease;
        }
        
        .flash-overlay.flash {
            animation: flash-bang 0.6s ease-out;
        }
        
        @keyframes flash-bang {
            0% { opacity: 1; }
            20% { opacity: 0.9; }
            100% { opacity: 0; }
        }
        
        /* ═══════════════════════════════════════════════════════════════
           PR TELECRONACA OVERLAY
           ═══════════════════════════════════════════════════════════════ */
        
        .telecronaca {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9998;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .telecronaca.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .telecronaca-title {
            font-size: clamp(1.5rem, 5vw, 3rem);
            font-weight: 300;
            color: var(--text);
            letter-spacing: 0.1em;
            margin-bottom: 2rem;
            text-transform: uppercase;
            animation: pulse-text 1s ease-in-out infinite;
        }
        
        @keyframes pulse-text {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .telecronaca-message {
            font-family: 'JetBrains Mono', monospace;
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            color: var(--accent);
            text-align: center;
            max-width: 80%;
            line-height: 1.8;
            margin-bottom: 2rem;
        }
        
        .telecronaca-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        
        .telecronaca-status .dot {
            width: 8px;
            height: 8px;
            background: #22c55e;
            border-radius: 50%;
            animation: pulse-dot 1s ease-in-out infinite;
        }
        
        .telecronaca-countdown {
            font-family: 'JetBrains Mono', monospace;
            font-size: clamp(3rem, 10vw, 8rem);
            font-weight: 300;
            color: var(--text);
            margin: 2rem 0;
            letter-spacing: 0.05em;
        }
        
        .telecronaca-cta {
            margin-top: 2rem;
            padding: 1rem 3rem;
            background: transparent;
            border: 1px solid var(--accent);
            border-radius: 100px;
            color: var(--text);
            font-size: 0.9rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .telecronaca-cta:hover {
            background: var(--accent);
            box-shadow: 0 0 40px var(--glow);
        }
        
        /* ═══════════════════════════════════════════════════════════════
           NOTIFICATION
           ═══════════════════════════════════════════════════════════════ */
        
        .notification {
            position: fixed;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            padding: 0.8rem 1.5rem;
            background: rgba(5,5,8,0.9);
            border: 1px solid var(--border);
            border-radius: 100px;
            font-size: 0.7rem;
            letter-spacing: 0.1em;
            color: var(--text);
            opacity: 0;
            transition: all 0.5s ease;
            z-index: 1001;
            backdrop-filter: blur(10px);
        }
        
        .notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        /* ═══════════════════════════════════════════════════════════════
           RESPONSIVE - Mobile & Landscape
           ═══════════════════════════════════════════════════════════════ */
        
        /* Mobile portrait */
        @media (max-width: 600px) {
            .container {
                padding: 1rem;
            }
            
            .organism {
                border-radius: 1rem;
                margin: 1rem 0;
            }
            
            .cta a {
                padding: 1rem 3rem;
                font-size: 0.85rem;
            }
            
            .data {
                gap: 1.5rem;
            }
        }
        
        /* Landscape mode */
        @media (max-height: 500px) {
            .container {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: space-around;
                align-items: center;
                padding: 1rem 2rem;
            }
            
            header {
                width: 100%;
                margin-bottom: 0.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .tagline {
                font-size: 0.6rem;
            }
            
            .organism {
                width: 50%;
                max-height: 60vh;
                margin: 0;
            }
            
            .data {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .datum-value {
                font-size: 1.2rem;
            }
            
            .progress {
                display: none;
            }
            
            .cta {
                position: absolute;
                bottom: 1rem;
                right: 2rem;
            }
            
            .cta a {
                padding: 0.8rem 2rem;
                font-size: 0.75rem;
            }
            
            footer {
                display: none;
            }
        }
        
        /* Very small screens */
        @media (max-height: 600px) and (orientation: portrait) {
            .organism {
                max-height: 35vh;
            }
            
            .progress {
                margin: 0.8rem 0;
            }
        }
    </style>
</head>
<body>
    <!-- Organic layers -->
    <div class="grain"></div>
    <div class="breath"></div>
    <div class="vignette"></div>
    
    <!-- Flash overlay for CTA click -->
    <div class="flash-overlay" id="flashOverlay"></div>
    
    <!-- PR Telecronaca overlay -->
    <div class="telecronaca" id="telecronaca">
        <div class="telecronaca-title">⚡ INCOMING PR ⚡</div>
        <div class="telecronaca-message" id="telecronacaMessage">
            preparing transmission...
        </div>
        <div class="telecronaca-status">
            <div class="dot"></div>
            <span>redirecting to github</span>
        </div>
        <div class="telecronaca-countdown" id="telecronacaCountdown">3</div>
        <button class="telecronaca-cta" id="telecronacaSkip">skip · go now</button>
    </div>
    
    <!-- Live indicator -->
    <div class="live">
        <div class="live-dot"></div>
        <span id="live-text">live</span>
    </div>
    
    <!-- Audio Toggle -->
    <button class="audio-toggle" id="audioToggle" title="Toggle ambient sound">
        <svg class="icon-off" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
        <svg class="icon-on" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
    </button>
    
    <!-- Notification -->
    <div class="notification" id="notification"></div>
    
    <div class="container">
        <!-- The Organism -->
        <div class="organism">
            <canvas id="canvas"></canvas>
        </div>
        
        <!-- Data -->
        <div class="data">
            <div class="datum">
                <div class="datum-value" id="level">1</div>
                <div class="datum-label">level</div>
            </div>
            <div class="datum">
                <div class="datum-value" id="score">0</div>
                <div class="datum-label">score</div>
            </div>
            <div class="datum">
                <div class="datum-value" id="souls">0</div>
                <div class="datum-label">souls</div>
            </div>
        </div>
        
        <!-- Progress -->
        <div class="progress">
            <div class="progress-label">next evolution · <span id="progress-pct">0</span>%</div>
            <div class="progress-track">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- CTA -->
        <div class="cta">
            <a href="https://github.com/fabriziosalmi/enjoy">contribute</a>
        </div>
        
        <footer>
            <a href="https://github.com/fabriziosalmi/enjoy/blob/main/LORE.md">lore</a>
            &nbsp;·&nbsp;
            <a href="voice.html">voice</a>
        </footer>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════
        // ORGANIC PARTICLE SYSTEM
        // ═══════════════════════════════════════════════════════════════
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let particles = [];
        let mouse = { x: null, y: null };
        let lastState = null;
        
        function resize() {
            const rect = canvas.parentElement.getBoundingClientRect();
            width = canvas.width = rect.width * devicePixelRatio;
            height = canvas.height = rect.height * devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            ctx.scale(devicePixelRatio, devicePixelRatio);
        }
        
        class Particle {
            constructor(name, karma) {
                this.name = name;
                this.karma = karma;
                this.x = Math.random() * (width / devicePixelRatio);
                this.y = Math.random() * (height / devicePixelRatio);
                
                // Karma-based effects:
                // Size: bigger = more karma (3-18px)
                this.baseRadius = 3 + Math.min(karma / 10, 15);
                this.radius = this.baseRadius;
                
                // Speed & vibration: more karma = more energetic
                const karmaFactor = Math.min(karma / 50, 1); // 0-1 scale
                this.speed = 0.2 + karmaFactor * 0.4;
                this.wobbleSpeed = 0.02 + karmaFactor * 0.04;
                
                // Color: low karma = cool blue, high karma = warm purple/pink
                // 240 = blue, 280 = purple, 320 = pink
                this.hue = 240 + karmaFactor * 80;
                
                // Glow intensity: more karma = brighter glow
                this.glowIntensity = 0.2 + karmaFactor * 0.4;
                
                // Pulse speed: high karma players pulse faster
                this.pulseSpeed = 0.002 + karmaFactor * 0.003;
                
                this.angle = Math.random() * Math.PI * 2;
                this.wobble = Math.random() * Math.PI * 2;
            }
            
            update(time) {
                // Organic movement - sine waves (faster for high karma)
                this.wobble += this.wobbleSpeed;
                this.angle += Math.sin(this.wobble) * 0.02;
                
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Soft boundaries
                const padding = 50;
                const w = width / devicePixelRatio;
                const h = height / devicePixelRatio;
                
                if (this.x < padding) this.angle = Math.random() * Math.PI - Math.PI/2;
                if (this.x > w - padding) this.angle = Math.random() * Math.PI + Math.PI/2;
                if (this.y < padding) this.angle = Math.random() * Math.PI;
                if (this.y > h - padding) this.angle = -Math.random() * Math.PI;
                
                // Breathing radius (pulses faster for high karma)
                this.radius = this.baseRadius + Math.sin(time * this.pulseSpeed + this.wobble) * 2;
                
                // Mouse attraction
                if (mouse.x !== null) {
                    const dx = mouse.x - this.x;
                    const dy = mouse.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 150) {
                        this.x += dx * 0.01;
                        this.y += dy * 0.01;
                    }
                }
            }
            
            draw() {
                // Glow (intensity based on karma)
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * 3
                );
                gradient.addColorStop(0, `hsla(${this.hue}, 70%, 65%, ${this.glowIntensity})`);
                gradient.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Core (brighter for high karma)
                const lightness = 65 + (this.glowIntensity * 20);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.hue}, 60%, ${lightness}%, 0.9)`;
                ctx.fill();
            }
        }
        
        function drawConnections() {
            ctx.strokeStyle = 'rgba(99, 102, 241, 0.05)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 120) {
                        const alpha = (1 - dist / 120) * 0.1;
                        ctx.strokeStyle = `rgba(99, 102, 241, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        
                        // Curved connection
                        const midX = (particles[i].x + particles[j].x) / 2;
                        const midY = (particles[i].y + particles[j].y) / 2 + Math.sin(Date.now() * 0.001) * 10;
                        ctx.quadraticCurveTo(midX, midY, particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
        }
        
        function animate(time) {
            ctx.fillStyle = 'rgba(5, 5, 8, 0.15)';
            ctx.fillRect(0, 0, width / devicePixelRatio, height / devicePixelRatio);
            
            drawConnections();
            
            particles.forEach(p => {
                p.update(time);
                p.draw();
            });
            
            requestAnimationFrame(animate);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // DATA LOADING
        // ═══════════════════════════════════════════════════════════════
        
        async function loadData() {
            try {
                const res = await fetch('https://raw.githubusercontent.com/fabriziosalmi/enjoy/main/state.json?' + Date.now());
                const state = await res.json();
                
                // Detect changes
                if (lastState) {
                    if (state.score?.total !== lastState.score?.total) notify('score changed');
                    if (state.levels?.current !== lastState.levels?.current) notify('level up');
                    if (Object.keys(state.players || {}).length !== Object.keys(lastState.players || {}).length) notify('new soul joined');
                }
                lastState = state;
                
                // Update UI
                document.getElementById('level').textContent = state.levels?.current || 1;
                document.getElementById('score').textContent = state.score?.total || 0;
                
                const players = state.players || {};
                const soulCount = Object.keys(players).length;
                document.getElementById('souls').textContent = soulCount;
                
                // Progress
                const next = state.levels?.next_unlock;
                if (next) {
                    const pct = Math.min(100, Math.round(
                        ((next.progress?.score || 0) / next.requires_score * 50) +
                        ((next.progress?.prs || 0) / next.requires_prs * 50)
                    ));
                    document.getElementById('progress-pct').textContent = pct;
                    document.getElementById('progress-fill').style.width = pct + '%';
                }
                
                // Sync particles with players
                Object.entries(players).forEach(([name, data]) => {
                    if (!particles.find(p => p.name === name)) {
                        particles.push(new Particle(name, data.karma || 0));
                    }
                });
                
            } catch (e) {
                console.log('polling...', e.message);
            }
        }
        
        function notify(msg) {
            const el = document.getElementById('notification');
            el.textContent = msg;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 3000);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // AMBIENT AUDIO SYSTEM
        // ═══════════════════════════════════════════════════════════════
        
        const AudioSystem = {
            ctx: null,
            masterGain: null,
            isPlaying: false,
            nodes: [],
            
            init() {
                if (this.ctx) return;
                
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0;
                this.masterGain.connect(this.ctx.destination);
                
                // Create ambient drone layers
                this.createDrone();
            },
            
            createDrone() {
                const ctx = this.ctx;
                
                // Layer 1: Low tone (120Hz) - audible on most speakers
                const osc1 = ctx.createOscillator();
                osc1.type = 'sine';
                osc1.frequency.value = 120;
                const gain1 = ctx.createGain();
                gain1.gain.value = 0.25;
                osc1.connect(gain1);
                gain1.connect(this.masterGain);
                this.nodes.push({ osc: osc1, gain: gain1, baseFreq: 120 });
                
                // Layer 2: Mid harmonic (180Hz)
                const osc2 = ctx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.value = 180;
                const gain2 = ctx.createGain();
                gain2.gain.value = 0.15;
                osc2.connect(gain2);
                gain2.connect(this.masterGain);
                this.nodes.push({ osc: osc2, gain: gain2, baseFreq: 180 });
                
                // Layer 3: High shimmer (300Hz with slight detune)
                const osc3 = ctx.createOscillator();
                osc3.type = 'sine';
                osc3.frequency.value = 300;
                osc3.detune.value = 5;
                const gain3 = ctx.createGain();
                gain3.gain.value = 0.08;
                osc3.connect(gain3);
                gain3.connect(this.masterGain);
                this.nodes.push({ osc: osc3, gain: gain3, baseFreq: 300 });
                
                // Layer 4: Ethereal pad (filtered noise) - more audible
                const bufferSize = 2 * ctx.sampleRate;
                const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;
                
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 400;
                noiseFilter.Q.value = 0.5;
                
                const noiseGain = ctx.createGain();
                noiseGain.gain.value = 0.06;
                
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                
                this.noiseNode = noise;
                this.noiseFilter = noiseFilter;
                
                // Start all oscillators
                osc1.start();
                osc2.start();
                osc3.start();
                noise.start();
                
                // Breathing modulation - synced with visual breath (8s)
                this.breathe();
            },
            
            breathe() {
                if (!this.isPlaying) return;
                
                const time = this.ctx.currentTime;
                const breathDuration = 8; // Match CSS breath animation
                
                // Modulate frequencies slightly
                this.nodes.forEach((node, i) => {
                    const detune = Math.sin(time * 0.1 + i) * 2;
                    node.osc.frequency.setValueAtTime(
                        node.baseFreq + detune,
                        time
                    );
                });
                
                // Modulate noise filter
                if (this.noiseFilter) {
                    const filterMod = 350 + Math.sin(time * 0.08) * 100;
                    this.noiseFilter.frequency.setValueAtTime(filterMod, time);
                }
                
                requestAnimationFrame(() => this.breathe());
            },
            
            fadeIn(duration = 3) {
                if (!this.ctx) this.init();
                
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                
                this.isPlaying = true;
                this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
                this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, this.ctx.currentTime);
                this.masterGain.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + duration);
                
                this.breathe();
            },
            
            fadeOut(duration = 2) {
                if (!this.ctx) return;
                
                this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
                this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, this.ctx.currentTime);
                this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + duration);
                
                setTimeout(() => {
                    this.isPlaying = false;
                }, duration * 1000);
            },
            
            toggle() {
                if (this.isPlaying) {
                    this.fadeOut();
                    return false;
                } else {
                    this.fadeIn();
                    return true;
                }
            },
            
            // Beckoning sound - gentle rising tone
            playBeckon() {
                if (!this.ctx || !this.isPlaying) return;
                
                const ctx = this.ctx;
                const now = ctx.currentTime;
                
                // Soft rising tone
                const osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(180, now);
                osc.frequency.exponentialRampToValueAtTime(280, now + 1.5);
                
                // Second harmonic
                const osc2 = ctx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(270, now);
                osc2.frequency.exponentialRampToValueAtTime(420, now + 1.5);
                
                // Envelope
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.08, now + 0.3);
                gain.gain.linearRampToValueAtTime(0.06, now + 1);
                gain.gain.linearRampToValueAtTime(0, now + 2);
                
                // Filter for warmth
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 0.5;
                
                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(now);
                osc2.start(now);
                osc.stop(now + 2);
                osc2.stop(now + 2);
            },
            
            // Proximity tone - pitch increases as you get closer
            proximityOsc: null,
            proximityGain: null,
            
            updateProximity(distance, maxDistance) {
                if (!this.ctx || !this.isPlaying) return;
                
                // Create proximity oscillator if needed
                if (!this.proximityOsc) {
                    this.proximityOsc = this.ctx.createOscillator();
                    this.proximityOsc.type = 'sine';
                    this.proximityGain = this.ctx.createGain();
                    this.proximityGain.gain.value = 0;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 1200;
                    
                    this.proximityOsc.connect(filter);
                    filter.connect(this.proximityGain);
                    this.proximityGain.connect(this.masterGain);
                    this.proximityOsc.start();
                }
                
                // Calculate intensity (0 = far, 1 = on button)
                const intensity = Math.max(0, 1 - (distance / maxDistance));
                
                // Frequency: 200Hz (far) → 600Hz (close)
                const freq = 200 + intensity * 400;
                this.proximityOsc.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.1);
                
                // Volume: 0 (far) → 0.15 (close)
                const vol = intensity * intensity * 0.15; // Exponential for dramatic effect
                this.proximityGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.1);
            },
            
            // Flash/thunder sound
            playFlash() {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                
                const ctx = this.ctx;
                const now = ctx.currentTime;
                
                // White noise burst
                const bufferSize = ctx.sampleRate * 0.3;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    // Decay envelope baked into noise
                    const decay = Math.exp(-i / (ctx.sampleRate * 0.05));
                    data[i] = (Math.random() * 2 - 1) * decay;
                }
                
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                
                // Low rumble
                const osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(80, now);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
                
                // Impact tone
                const impact = ctx.createOscillator();
                impact.type = 'sine';
                impact.frequency.setValueAtTime(400, now);
                impact.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                // Gains
                const noiseGain = ctx.createGain();
                noiseGain.gain.setValueAtTime(0.8, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                
                const oscGain = ctx.createGain();
                oscGain.gain.setValueAtTime(0.4, now);
                oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                
                const impactGain = ctx.createGain();
                impactGain.gain.setValueAtTime(0.5, now);
                impactGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                
                // Connect
                noise.connect(noiseGain);
                osc.connect(oscGain);
                impact.connect(impactGain);
                noiseGain.connect(ctx.destination); // Direct to output, bypass master
                oscGain.connect(ctx.destination);
                impactGain.connect(ctx.destination);
                
                // Play
                noise.start(now);
                osc.start(now);
                impact.start(now);
                noise.stop(now + 0.3);
                osc.stop(now + 0.5);
                impact.stop(now + 0.2);
            }
        };
        
        // Audio toggle button
        const audioToggle = document.getElementById('audioToggle');
        
        audioToggle.addEventListener('click', () => {
            const isNowPlaying = AudioSystem.toggle();
            audioToggle.classList.toggle('active', isNowPlaying);
            localStorage.setItem('audioEnabled', isNowPlaying);
        });
        
        // Auto-enable audio on first interaction (browser requires user gesture)
        const audioPreference = localStorage.getItem('audioEnabled');
        if (audioPreference !== 'false') {
            // Default: audio ON (enable on first click anywhere)
            const enableOnFirstInteraction = () => {
                if (!AudioSystem.isPlaying) {
                    AudioSystem.fadeIn();
                    audioToggle.classList.add('active');
                    localStorage.setItem('audioEnabled', 'true');
                }
                document.removeEventListener('click', enableOnFirstInteraction);
            };
            document.addEventListener('click', enableOnFirstInteraction);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // INIT
        // ═══════════════════════════════════════════════════════════════
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouse.x = null;
            mouse.y = null;
        });
        
        window.addEventListener('resize', resize);
        
        resize();
        loadData();
        animate(0);
        
        // Poll every 5 seconds
        setInterval(loadData, 5000);
        
        // ═══════════════════════════════════════════════════════════════
        // SUBTLE LIGHT FX ON DATA CARDS
        // ═══════════════════════════════════════════════════════════════
        
        const datums = document.querySelectorAll('.datum');
        
        function randomLightPulse() {
            // Pick a random card
            const datum = datums[Math.floor(Math.random() * datums.length)];
            const value = datum.querySelector('.datum-value');
            
            // Random position for the glow
            const x = 20 + Math.random() * 60;
            const y = 20 + Math.random() * 60;
            
            // Set glow position and intensity
            datum.style.setProperty('--glow-x', x + '%');
            datum.style.setProperty('--glow-y', y + '%');
            datum.style.setProperty('--glow-opacity', '0.15');
            value.style.setProperty('--text-glow', '0.4');
            
            // Fade out
            setTimeout(() => {
                datum.style.setProperty('--glow-opacity', '0');
                value.style.setProperty('--text-glow', '0');
            }, 800 + Math.random() * 400);
        }
        
        // Random pulses every 2-5 seconds
        function scheduleNextPulse() {
            const delay = 2000 + Math.random() * 3000;
            setTimeout(() => {
                randomLightPulse();
                scheduleNextPulse();
            }, delay);
        }
        
        scheduleNextPulse();
        
        // ═══════════════════════════════════════════════════════════════
        // CTA BECKONING SYSTEM
        // ═══════════════════════════════════════════════════════════════
        
        const ctaElement = document.querySelector('.cta');
        const ctaLink = ctaElement.querySelector('a');
        let isBeckoning = false;
        let beckonTarget = null;
        
        function getCTACenter() {
            const rect = ctaLink.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2 - canvasRect.left,
                y: rect.top + rect.height / 2 - canvasRect.top
            };
        }
        
        function getCTARect() {
            return ctaLink.getBoundingClientRect();
        }
        
        function triggerBeckon() {
            if (isBeckoning) return;
            isBeckoning = true;
            
            // Visual: CSS animation
            ctaElement.classList.add('beckoning');
            
            // Audio: gentle rising tone
            AudioSystem.playBeckon();
            
            // Particles: attract toward CTA for 2 seconds
            beckonTarget = getCTACenter();
            
            // Reset after animation
            setTimeout(() => {
                ctaElement.classList.remove('beckoning');
                isBeckoning = false;
                beckonTarget = null;
            }, 2000);
        }
        
        // Enhanced particle update with beckoning attraction
        const originalParticleUpdate = Particle.prototype.update;
        Particle.prototype.update = function(time) {
            originalParticleUpdate.call(this, time);
            
            // Subtle pull toward CTA during beckon
            if (beckonTarget) {
                const dx = beckonTarget.x - this.x;
                const dy = beckonTarget.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const strength = 0.003 * (1 - Math.min(dist / 400, 1));
                this.x += dx * strength;
                this.y += dy * strength;
            }
        };
        
        // Beckon every 12-20 seconds
        function scheduleNextBeckon() {
            const delay = 12000 + Math.random() * 8000;
            setTimeout(() => {
                triggerBeckon();
                scheduleNextBeckon();
            }, delay);
        }
        
        // Start beckoning after 8 seconds
        setTimeout(() => {
            scheduleNextBeckon();
        }, 8000);
        
        // ═══════════════════════════════════════════════════════════════
        // PROXIMITY AUDIO - Sound gets higher as you approach CTA
        // ═══════════════════════════════════════════════════════════════
        
        const maxProximityDistance = 300; // pixels
        
        document.addEventListener('mousemove', (e) => {
            const rect = getCTARect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            AudioSystem.updateProximity(distance, maxProximityDistance);
        });
        
        // Reset proximity when mouse leaves window
        document.addEventListener('mouseleave', () => {
            AudioSystem.updateProximity(maxProximityDistance * 2, maxProximityDistance);
        });
        
        // ═══════════════════════════════════════════════════════════════
        // CTA CLICK - FLASH + TELECRONACA
        // ═══════════════════════════════════════════════════════════════
        
        const flashOverlay = document.getElementById('flashOverlay');
        const telecronaca = document.getElementById('telecronaca');
        const telecronacaMessage = document.getElementById('telecronacaMessage');
        const telecronacaCountdown = document.getElementById('telecronacaCountdown');
        const telecronacaSkip = document.getElementById('telecronacaSkip');
        
        const prMessages = [
            "A brave soul steps into the arena...",
            "The organism awaits your contribution...",
            "Will your code survive the merge?",
            "The collective holds its breath...",
            "Another challenger approaches...",
            "May the validators be in your favor...",
            "The repository hungers for new blood...",
            "Your PR will be judged by the masses...",
        ];
        
        let countdownInterval = null;
        
        function triggerFlashAndTelecronaca(e) {
            e.preventDefault();
            
            // Kill proximity sound
            AudioSystem.updateProximity(9999, maxProximityDistance);
            
            // FLASH!
            AudioSystem.playFlash();
            flashOverlay.classList.add('flash');
            
            setTimeout(() => {
                flashOverlay.classList.remove('flash');
                
                // Show telecronaca
                const randomMsg = prMessages[Math.floor(Math.random() * prMessages.length)];
                telecronacaMessage.textContent = randomMsg;
                telecronaca.classList.add('active');
                
                // Countdown
                let count = 3;
                telecronacaCountdown.textContent = count;
                
                countdownInterval = setInterval(() => {
                    count--;
                    if (count > 0) {
                        telecronacaCountdown.textContent = count;
                    } else {
                        clearInterval(countdownInterval);
                        goToGitHub();
                    }
                }, 1000);
                
            }, 200);
        }
        
        function goToGitHub() {
            telecronaca.classList.remove('active');
            window.open('https://github.com/fabriziosalmi/enjoy', '_blank');
        }
        
        ctaLink.addEventListener('click', triggerFlashAndTelecronaca);
        
        telecronacaSkip.addEventListener('click', () => {
            clearInterval(countdownInterval);
            goToGitHub();
        });
        
        // Click outside to cancel
        telecronaca.addEventListener('click', (e) => {
            if (e.target === telecronaca) {
                clearInterval(countdownInterval);
                telecronaca.classList.remove('active');
            }
        });
    </script>
</body>
</html>
